function main_massa_mola_completo()
%   MAIN_MASSA_MOLA_COMPLETO - Síntese completa de controladores H∞
%
%   Sistema massa-mola-amortecedor baseado no Exemplo 12 (genSaveDataEx12)
%   Seguindo a lógica de G.W. Gabriel, J.C. Geromel & K.M. Grigoriadis
%
%   ETAPA 1: Síntese Nominal (sem incertezas)
%   ETAPA 2: Síntese Robusta (com incertezas)
%
%   Métodos utilizados:
%   - Abordagem Intervalar: estHInfSintLMILab
%   - Abordagem Politópica: estHInfSintPolyLMILab
%   - Abordagem Nominal: estHInfSintLMILabPrec
%
%   Autor: Baseado em genSaveDataEx12
%   Data: 2025

    clear; clc;
    fprintf('=== SÍNTESE COMPLETA DE CONTROLADORES H∞ - SISTEMA MASSA-MOLA ===\n\n');

    % Adicionar caminhos necessários
    addpath('funcoes');
    addpath('functions');
    addpath('functions/Optimize');
    addpath('HInf - Análise - Intervalar/funcoes');
    addpath('HInf - Análise - Intervalar/funcoes/Diversas');

    % Inicializar INTLAB
    intvalinit('DisplayInfSup');

    %% =================================================================
    %% DEFINIÇÃO DO SISTEMA (baseado em genSaveDataEx12)
    %% =================================================================

    % Parâmetros físicos seguindo genSaveDataEx12
    m1 = 0.5;  % massa 1 [kg]
    m2 = 1.0;  % massa 2 [kg]
    k1 = 12;   % constante da mola 1 [N/m]
    k2 = 7;    % constante da mola 2 [N/m]
    b = 0.2;   % coeficiente de amortecimento [N.s/m]

    % Parâmetros de síntese
    h = 0.02;       % Período de amostragem (como no exemplo)
    qtdDiv = 5;
    delta = h/qtdDiv;
    tol = 1e-5;     % Tolerância

    fprintf('Parâmetros do sistema (baseado em genSaveDataEx12):\n');
    fprintf('  Massa 1 (m1): %.1f kg\n', m1);
    fprintf('  Massa 2 (m2): %.1f kg\n', m2);
    fprintf('  Mola 1 (k1): %.0f N/m\n', k1);
    fprintf('  Mola 2 (k2): %.0f N/m\n', k2);
    fprintf('  Amortecimento (b): %.1f N.s/m\n', b);
    fprintf('  Período de amostragem (h): %.3f s\n', h);
    fprintf('  Delta: %.4f\n', delta);
    fprintf('  Tolerância: %.0e\n\n', tol);

    %% =================================================================
    %% ETAPA 1: SÍNTESE NOMINAL (SEM INCERTEZAS)
    %% =================================================================

    fprintf('=====================================\n');
    fprintf('ETAPA 1: SÍNTESE NOMINAL (SEM INCERTEZAS)\n');
    fprintf('=====================================\n\n');

    % Matrizes intervalares nominais (sem incerteza)
    m1_nom = infsup(m1, m1);
    m2_nom = infsup(m2, m2);
    k1_nom = infsup(k1, k1);
    k2_nom = infsup(k2, k2);
    b_nom = infsup(b, b);

    % Sistema nominal seguindo estrutura do genSaveDataEx12
    A_nom = [0              0       1       0;
             0              0       0       1;
             (-k2_nom-k1_nom)/m1_nom    k2_nom/m1_nom   -b_nom/m1_nom   b_nom/m1_nom;
             k2_nom/m2_nom          -k2_nom/m2_nom  b_nom/m2_nom    -b_nom/m2_nom];

    B_nom = [0; 0; 0; 1/m2_nom];  % Entrada de controle na massa 2

    E_nom = [0; 0; 1/m1_nom; 0];  % Entrada de perturbação na massa 1

    C_nom = [0 10 0 0;            % Saída 1: 10x posição massa 1
             0  0 0 1;            % Saída 2: velocidade massa 2
             0  0 0 0];           % Saída 3: zero

    C_nom = infsup(C_nom, C_nom);

    D_nom = [0; 0; 1];            % Feedthrough
    D_nom = infsup(D_nom, D_nom);

    fprintf('Matrizes nominais calculadas (estrutura do genSaveDataEx12).\n\n');

    %% MÉTODO 1: Abordagem Intervalar Nominal
    fprintf('--- MÉTODO 1: Abordagem Intervalar (Nominal) ---\n');
    try
        tic;
        resultado_int_nom = estHInfSintLMILab(A_nom, B_nom, E_nom, C_nom, D_nom, h, delta, tol);
        tempo_int_nom = toc;

        if isfield(resultado_int_nom, 'factivel') && resultado_int_nom.factivel
            K_int_nom = resultado_int_nom.K;
            gamma_int_nom = resultado_int_nom.gamma;
            sucesso_int_nom = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_int_nom(1), K_int_nom(2), K_int_nom(3), K_int_nom(4));
            fprintf('  Norma γ: %.6f\n', gamma_int_nom);
            fprintf('  Tempo: %.4f s\n\n', tempo_int_nom);
        else
            sucesso_int_nom = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_int_nom = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% MÉTODO 2: Abordagem Politópica Nominal
    fprintf('--- MÉTODO 2: Abordagem Politópica (Nominal) ---\n');
    try
        % Crear politopo nominal com um único vértice
        poly_nom.APoly = {[0              0       1       0;
                           0              0       0       1;
                           (-k2-k1)/m1    k2/m1   -b/m1   b/m1;
                           k2/m2          -k2/m2  b/m2    -b/m2]};

        poly_nom.BPoly = {[0; 0; 0; 1/m2]};
        poly_nom.EPoly = {[0; 0; 1/m1; 0]};
        poly_nom.CPoly = {[0 10 0 0; 0 0 0 1; 0 0 0 0]};
        poly_nom.DPoly = {[0; 0; 1]};

        tic;
        resultado_poly_nom = estHInfSintPolyLMILab(poly_nom, h, delta, tol);
        tempo_poly_nom = toc;

        if isfield(resultado_poly_nom, 'factivel') && resultado_poly_nom.factivel
            K_poly_nom = resultado_poly_nom.K;
            gamma_poly_nom = resultado_poly_nom.gamma;
            sucesso_poly_nom = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_poly_nom(1), K_poly_nom(2), K_poly_nom(3), K_poly_nom(4));
            fprintf('  Norma γ: %.6f\n', gamma_poly_nom);
            fprintf('  Tempo: %.4f s\n\n', tempo_poly_nom);
        else
            sucesso_poly_nom = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_poly_nom = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% MÉTODO 3: Abordagem Nominal Clássica
    fprintf('--- MÉTODO 3: Abordagem Nominal (estHInfSintLMILabPrec) ---\n');
    try
        % Valores centrais para abordagem nominal
        A_nom_central = [0              0       1       0;
                         0              0       0       1;
                         (-k2-k1)/m1    k2/m1   -b/m1   b/m1;
                         k2/m2          -k2/m2  b/m2    -b/m2];

        B_nom_central = [0; 0; 0; 1/m2];
        E_nom_central = [0; 0; 1/m1; 0];
        C_nom_central = [0 10 0 0; 0 0 0 1; 0 0 0 0];
        D_nom_central = [0; 0; 1];

        tic;
        resultado_nom = estHInfSintLMILabPrec(A_nom_central, B_nom_central, E_nom_central, C_nom_central, D_nom_central, h, delta, tol);
        tempo_nom = toc;

        if isfield(resultado_nom, 'factivel') && resultado_nom.factivel
            K_nom = resultado_nom.K;
            gamma_nom = resultado_nom.gamma;
            sucesso_nom = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_nom(1), K_nom(2), K_nom(3), K_nom(4));
            fprintf('  Norma γ: %.6f\n', gamma_nom);
            fprintf('  Tempo: %.4f s\n\n', tempo_nom);
        else
            sucesso_nom = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_nom = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% =================================================================
    %% ETAPA 2: SÍNTESE ROBUSTA (COM INCERTEZAS)
    %% =================================================================

    fprintf('=====================================\n');
    fprintf('ETAPA 2: SÍNTESE ROBUSTA (COM INCERTEZAS)\n');
    fprintf('=====================================\n\n');

    % Definir incertezas seguindo genSaveDataEx12
    m1_unc = infsup(m1, m1);                    % sem incerteza em m1
    m2_unc = infsup(m2, m2);                    % sem incerteza em m2
    b_unc = infsup(b*0.95, b*1.05);            % b com ±5% de incerteza
    k1_unc = infsup(k1, k1);                   % sem incerteza em k1
    k2_unc = infsup(k2*0.98, k2*1.02);        % k2 com ±2% de incerteza

    fprintf('Parâmetros com incertezas (seguindo genSaveDataEx12):\n');
    fprintf('  Massa 1 (m1): [%.2f, %.2f] kg (sem incerteza)\n', m1_unc.inf, m1_unc.sup);
    fprintf('  Massa 2 (m2): [%.2f, %.2f] kg (sem incerteza)\n', m2_unc.inf, m2_unc.sup);
    fprintf('  Amortecimento (b): [%.3f, %.3f] N.s/m (±5%%)\n', b_unc.inf, b_unc.sup);
    fprintf('  Mola 1 (k1): [%.1f, %.1f] N/m (sem incerteza)\n', k1_unc.inf, k1_unc.sup);
    fprintf('  Mola 2 (k2): [%.2f, %.2f] N/m (±2%%)\n\n', k2_unc.inf, k2_unc.sup);

    % Sistema com incertezas
    A_unc = [0                          0              1              0;
             0                          0              0              1;
             (-k2_unc-k1_unc)/m1_unc   k2_unc/m1_unc  -b_unc/m1_unc  b_unc/m1_unc;
             k2_unc/m2_unc             -k2_unc/m2_unc  b_unc/m2_unc  -b_unc/m2_unc];

    B_unc = [0; 0; 0; 1/m2_unc];
    E_unc = [0; 0; 1/m1_unc; 0];
    C_unc = infsup(C_nom_central, C_nom_central);  % sem incerteza
    D_unc = infsup(D_nom_central, D_nom_central);  % sem incerteza

    fprintf('Matrizes intervalares com incertezas calculadas.\n\n');

    %% MÉTODO 4: Abordagem Intervalar Robusta
    fprintf('--- MÉTODO 4: Abordagem Intervalar (Robusta) ---\n');
    try
        tic;
        resultado_int_rob = estHInfSintLMILab(A_unc, B_unc, E_unc, C_unc, D_unc, h, delta, tol);
        tempo_int_rob = toc;

        if isfield(resultado_int_rob, 'factivel') && resultado_int_rob.factivel
            K_int_rob = resultado_int_rob.K;
            gamma_int_rob = resultado_int_rob.gamma;
            sucesso_int_rob = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_int_rob(1), K_int_rob(2), K_int_rob(3), K_int_rob(4));
            fprintf('  Norma γ: %.6f\n', gamma_int_rob);
            fprintf('  Tempo: %.4f s\n\n', tempo_int_rob);
        else
            sucesso_int_rob = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_int_rob = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% MÉTODO 5: Abordagem Politópica Robusta
    fprintf('--- MÉTODO 5: Abordagem Politópica (Robusta) ---\n');
    try
        % Gerar vértices do politopo seguindo genSaveDataEx12
        b_vals = [b_unc.inf, b_unc.sup];
        k2_vals = [k2_unc.inf, k2_unc.sup];

        % Politopo com vértices das incertezas
        idx = 0;
        for i = 1:length(b_vals)
            for j = 1:length(k2_vals)
                idx = idx + 1;

                poly_rob.APoly{idx} = [0                                  0                 1                  0;
                                       0                                  0                 0                  1;
                                       (-k2_vals(j)-k1)/m1               k2_vals(j)/m1    -b_vals(i)/m1      b_vals(i)/m1;
                                       k2_vals(j)/m2                     -k2_vals(j)/m2    b_vals(i)/m2      -b_vals(i)/m2];

                poly_rob.BPoly{idx} = [0; 0; 0; 1/m2];    % B2
                poly_rob.EPoly{idx} = [0; 0; 1/m1; 0];    % B1
                poly_rob.CPoly{idx} = [0 10 0 0; 0 0 0 1; 0 0 0 0];
                poly_rob.DPoly{idx} = [0; 0; 1];          % D2
            end
        end

        fprintf('Politopo gerado com %d vértices (seguindo genSaveDataEx12).\n', idx);

        tic;
        resultado_poly_rob = estHInfSintPolyLMILab(poly_rob, h, delta, tol);
        tempo_poly_rob = toc;

        if isfield(resultado_poly_rob, 'factivel') && resultado_poly_rob.factivel
            K_poly_rob = resultado_poly_rob.K;
            gamma_poly_rob = resultado_poly_rob.gamma;
            sucesso_poly_rob = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_poly_rob(1), K_poly_rob(2), K_poly_rob(3), K_poly_rob(4));
            fprintf('  Norma γ: %.6f\n', gamma_poly_rob);
            fprintf('  Tempo: %.4f s\n\n', tempo_poly_rob);
        else
            sucesso_poly_rob = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_poly_rob = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% MÉTODO 6: Abordagem Nominal com Sistema Central
    fprintf('--- MÉTODO 6: Abordagem Nominal (Sistema Central das Incertezas) ---\n');
    try
        % Sistema central das incertezas
        b_central = (b_unc.inf + b_unc.sup) / 2;
        k2_central = (k2_unc.inf + k2_unc.sup) / 2;

        A_central = [0                            0                   1                   0;
                     0                            0                   0                   1;
                     (-k2_central-k1)/m1         k2_central/m1       -b_central/m1       b_central/m1;
                     k2_central/m2               -k2_central/m2       b_central/m2       -b_central/m2];

        B_central = [0; 0; 0; 1/m2];
        E_central = [0; 0; 1/m1; 0];

        tic;
        resultado_central = estHInfSintLMILabPrec(A_central, B_central, E_central, C_nom_central, D_nom_central, h, delta, tol);
        tempo_central = toc;

        if isfield(resultado_central, 'factivel') && resultado_central.factivel
            K_central = resultado_central.K;
            gamma_central = resultado_central.gamma;
            sucesso_central = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_central(1), K_central(2), K_central(3), K_central(4));
            fprintf('  Norma γ: %.6f\n', gamma_central);
            fprintf('  Tempo: %.4f s\n\n', tempo_central);
        else
            sucesso_central = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_central = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% =================================================================
    %% ETAPA 3: SÍNTESE CONTÍNUA (COM INCERTEZAS)
    %% =================================================================

    fprintf('=====================================\n');
    fprintf('ETAPA 3: SÍNTESE CONTÍNUA (COM INCERTEZAS)\n');
    fprintf('=====================================\n');
    fprintf('Usando funções: synHInfKContIntLMILab e synHInfKContPoly\n\n');

    % Preparar matrizes e parâmetros para síntese contínua
    fprintf('Preparando matrizes para síntese contínua...\n');

    % Matrizes para síntese contínua (usando sistema com incertezas)
    A_cont_unc = A_unc;
    B2_cont_unc = B_unc;          % Entrada de controle (B2)
    B1_cont_unc = E_unc;          % Entrada de perturbação (B1)
    C_cont_unc = C_unc;
    D2_cont_unc = D_unc;          % Feedthrough do controle (D2)

    % Criar matriz D1 (feedthrough da perturbação) com dimensões corretas
    num_saidas = size(C_cont_unc.inf, 1);        % número de saídas
    num_perturbacoes = size(B1_cont_unc.inf, 2); % número de perturbações
    D1_cont_unc = infsup(zeros(num_saidas, num_perturbacoes), zeros(num_saidas, num_perturbacoes));

    % Inicializar estrutura de parâmetros corretamente
    param_cont = struct();
    param_cont.tol = tol;
    param_cont.maxNormOfK = 1e8;  % Campo necessário para synHInfKContPoly

    % Inicializar variáveis de sucesso e resultados
    sucesso_cont_int_rob = false;
    sucesso_cont_poly_rob = false;
    K_cont_int_rob = [];
    gamma_cont_int_rob = NaN;
    tempo_cont_int_rob = 0;
    K_cont_poly_rob = [];
    gamma_cont_poly_rob = NaN;
    tempo_cont_poly_rob = 0;

    % Variáveis para métodos alternativos contínuos (versões não-LMILab)
    sucesso_cont_int_alt = false;
    sucesso_cont_poly_alt = false;
    K_cont_int_alt = [];
    gamma_cont_int_alt = NaN;
    tempo_cont_int_alt = 0;
    K_cont_poly_alt = [];
    gamma_cont_poly_alt = NaN;
    tempo_cont_poly_alt = 0;

    fprintf('Dimensões das matrizes contínuas:\n');
    fprintf('  A: %dx%d, B2: %dx%d, B1: %dx%d\n', size(A_cont_unc.inf,1), size(A_cont_unc.inf,2), size(B2_cont_unc.inf,1), size(B2_cont_unc.inf,2), size(B1_cont_unc.inf,1), size(B1_cont_unc.inf,2));
    fprintf('  C: %dx%d, D2: %dx%d, D1: %dx%d\n\n', size(C_cont_unc.inf,1), size(C_cont_unc.inf,2), size(D2_cont_unc.inf,1), size(D2_cont_unc.inf,2), size(D1_cont_unc.inf,1), size(D1_cont_unc.inf,2));

    %% MÉTODO 7: Abordagem Intervalar Contínua (Robusta)
    fprintf('--- MÉTODO 7: Abordagem Intervalar Contínua (Robusta) ---\n');
    try

        tic;
        resultado_cont_int_rob = synHInfKContIntLMILab(A_cont_unc, B2_cont_unc, B1_cont_unc, C_cont_unc, D2_cont_unc, D1_cont_unc, param_cont);
        tempo_cont_int_rob = toc;

        if isfield(resultado_cont_int_rob, 'feas') && resultado_cont_int_rob.feas == 1
            K_cont_int_rob = resultado_cont_int_rob.K;
            gamma_cont_int_rob = resultado_cont_int_rob.mu;
            sucesso_cont_int_rob = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_cont_int_rob(1), K_cont_int_rob(2), K_cont_int_rob(3), K_cont_int_rob(4));
            fprintf('  Norma γ: %.6f\n', gamma_cont_int_rob);
            fprintf('  Tempo: %.4f s\n\n', tempo_cont_int_rob);
        else
            sucesso_cont_int_rob = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_cont_int_rob = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% MÉTODO 8: Abordagem Politópica Contínua (Robusta)
    fprintf('--- MÉTODO 8: Abordagem Politópica Contínua (Robusta) ---\n');
    try
        % Preparar politopo para síntese contínua
        fprintf('Preparando politopo contínuo...\n');

        % Usar o mesmo politopo robusto, mas adicionar D1Poly (feedthrough da perturbação)
        poly_cont_rob = poly_rob;  % Copiar estrutura existente

        % Adicionar D1Poly (feedthrough da perturbação) para cada vértice
        % Dimensões: num_saidas x num_perturbacoes
        d1_matriz = zeros(num_saidas, num_perturbacoes);
        for idx_vert = 1:length(poly_cont_rob.APoly)
            poly_cont_rob.D1Poly{idx_vert} = d1_matriz;  % D1 = zeros com dimensões corretas
        end

        fprintf('Politopo contínuo preparado com %d vértices.\n', length(poly_cont_rob.APoly));

        tic;
        resultado_cont_poly_rob = synHInfKContPoly(poly_cont_rob.APoly, poly_cont_rob.BPoly, poly_cont_rob.EPoly, poly_cont_rob.CPoly, poly_cont_rob.DPoly, poly_cont_rob.D1Poly, param_cont);
        tempo_cont_poly_rob = toc;

        if isfield(resultado_cont_poly_rob, 'feas') && resultado_cont_poly_rob.feas == 1
            K_cont_poly_rob = resultado_cont_poly_rob.K;
            gamma_cont_poly_rob = resultado_cont_poly_rob.norm;
            sucesso_cont_poly_rob = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_cont_poly_rob(1), K_cont_poly_rob(2), K_cont_poly_rob(3), K_cont_poly_rob(4));
            fprintf('  Norma γ: %.6f\n', gamma_cont_poly_rob);
            fprintf('  Tempo: %.4f s\n\n', tempo_cont_poly_rob);
        else
            sucesso_cont_poly_rob = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_cont_poly_rob = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% MÉTODO 9: Abordagem Intervalar Contínua Alternativa (synHInfKContInt)
    fprintf('--- MÉTODO 9: Abordagem Intervalar Contínua Alternativa (synHInfKContInt) ---\n');
    try
        tic;
        resultado_cont_int_alt = synHInfKContInt(A_cont_unc, B2_cont_unc, B1_cont_unc, C_cont_unc, D2_cont_unc, D1_cont_unc, param_cont);
        tempo_cont_int_alt = toc;

        if isfield(resultado_cont_int_alt, 'feas') && resultado_cont_int_alt.feas == 1
            K_cont_int_alt = resultado_cont_int_alt.K;
            gamma_cont_int_alt = resultado_cont_int_alt.norm;
            sucesso_cont_int_alt = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_cont_int_alt(1), K_cont_int_alt(2), K_cont_int_alt(3), K_cont_int_alt(4));
            fprintf('  Norma γ: %.6f\n', gamma_cont_int_alt);
            fprintf('  Tempo: %.4f s\n\n', tempo_cont_int_alt);
        else
            sucesso_cont_int_alt = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_cont_int_alt = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% MÉTODO 10: Abordagem Politópica Contínua Alternativa (synHInfKContPoly)
    fprintf('--- MÉTODO 10: Abordagem Politópica Contínua Alternativa (synHInfKContPoly) ---\n');
    try
        tic;
        % Usar o mesmo politopo contínuo preparado anteriormente
        resultado_cont_poly_alt = synHInfKContPoly(poly_cont_rob.APoly, poly_cont_rob.BPoly, poly_cont_rob.EPoly, poly_cont_rob.CPoly, poly_cont_rob.DPoly, poly_cont_rob.D1Poly, param_cont);
        tempo_cont_poly_alt = toc;

        if isfield(resultado_cont_poly_alt, 'feas') && resultado_cont_poly_alt.feas == 1
            K_cont_poly_alt = resultado_cont_poly_alt.K;
            gamma_cont_poly_alt = resultado_cont_poly_alt.norm;
            sucesso_cont_poly_alt = true;

            fprintf('✓ Síntese bem-sucedida!\n');
            fprintf('  Ganho K: [%.6f %.6f %.6f %.6f]\n', K_cont_poly_alt(1), K_cont_poly_alt(2), K_cont_poly_alt(3), K_cont_poly_alt(4));
            fprintf('  Norma γ: %.6f\n', gamma_cont_poly_alt);
            fprintf('  Tempo: %.4f s\n\n', tempo_cont_poly_alt);
        else
            sucesso_cont_poly_alt = false;
            fprintf('✗ Síntese falhou!\n\n');
        end

    catch ME
        sucesso_cont_poly_alt = false;
        fprintf('✗ Erro: %s\n\n', ME.message);
    end

    %% =================================================================
    %% RESUMO DOS RESULTADOS
    %% =================================================================

    fprintf('=====================================\n');
    fprintf('RESUMO FINAL DOS RESULTADOS\n');
    fprintf('=====================================\n\n');

    % Tabela resumo
    fprintf('MÉTODO                           | STATUS | γ²        | TEMPO (s) | GANHO K (1x4)\n');
    fprintf('--------------------------------|--------|-----------|-----------|----------------------------------------\n');

    % Resultados nominais
    if sucesso_int_nom
        fprintf('1. Intervalar (Nominal)          | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_int_nom^2, tempo_int_nom, K_int_nom(1), K_int_nom(2), K_int_nom(3), K_int_nom(4));
    else
        fprintf('1. Intervalar (Nominal)          | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    if sucesso_poly_nom
        fprintf('2. Politópica (Nominal)          | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_poly_nom^2, tempo_poly_nom, K_poly_nom(1), K_poly_nom(2), K_poly_nom(3), K_poly_nom(4));
    else
        fprintf('2. Politópica (Nominal)          | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    if sucesso_nom
        fprintf('3. Nominal Clássica              | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_nom^2, tempo_nom, K_nom(1), K_nom(2), K_nom(3), K_nom(4));
    else
        fprintf('3. Nominal Clássica              | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    fprintf('--------------------------------|--------|-----------|-----------|----------------------------------------\n');

    % Resultados robustos
    if sucesso_int_rob
        fprintf('4. Intervalar (Robusta)          | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_int_rob^2, tempo_int_rob, K_int_rob(1), K_int_rob(2), K_int_rob(3), K_int_rob(4));
    else
        fprintf('4. Intervalar (Robusta)          | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    if sucesso_poly_rob
        fprintf('5. Politópica (Robusta)          | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_poly_rob^2, tempo_poly_rob, K_poly_rob(1), K_poly_rob(2), K_poly_rob(3), K_poly_rob(4));
    else
        fprintf('5. Politópica (Robusta)          | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    if sucesso_central
        fprintf('6. Nominal (Sistema Central)     | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_central^2, tempo_central, K_central(1), K_central(2), K_central(3), K_central(4));
    else
        fprintf('6. Nominal (Sistema Central)     | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    fprintf('--------------------------------|--------|-----------|-----------|----------------------------------------\n');

    % Resultados contínuos
    if sucesso_cont_int_rob && ~isempty(K_cont_int_rob) && length(K_cont_int_rob) >= 4
        fprintf('7. Intervalar (Contínua)         | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_cont_int_rob^2, tempo_cont_int_rob, K_cont_int_rob(1), K_cont_int_rob(2), K_cont_int_rob(3), K_cont_int_rob(4));
    else
        fprintf('7. Intervalar (Contínua)         | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    if sucesso_cont_poly_rob && ~isempty(K_cont_poly_rob) && length(K_cont_poly_rob) >= 4
        fprintf('8. Politópica (Contínua)         | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_cont_poly_rob^2, tempo_cont_poly_rob, K_cont_poly_rob(1), K_cont_poly_rob(2), K_cont_poly_rob(3), K_cont_poly_rob(4));
    else
        fprintf('8. Politópica (Contínua)         | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    if sucesso_cont_int_alt && ~isempty(K_cont_int_alt) && length(K_cont_int_alt) >= 4
        fprintf('9. Intervalar (Cont-Alt)         | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_cont_int_alt^2, tempo_cont_int_alt, K_cont_int_alt(1), K_cont_int_alt(2), K_cont_int_alt(3), K_cont_int_alt(4));
    else
        fprintf('9. Intervalar (Cont-Alt)         | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    if sucesso_cont_poly_alt && ~isempty(K_cont_poly_alt) && length(K_cont_poly_alt) >= 4
        fprintf('10. Politópica (Cont-Alt)        | %-6s | %9.6f | %8.4f | [%.4f %.4f %.4f %.4f]\n', ...
            'OK', gamma_cont_poly_alt^2, tempo_cont_poly_alt, K_cont_poly_alt(1), K_cont_poly_alt(2), K_cont_poly_alt(3), K_cont_poly_alt(4));
    else
        fprintf('10. Politópica (Cont-Alt)        | %-6s | %9s | %8s | %s\n', ...
            'FALHOU', 'N/A', 'N/A', 'N/A');
    end

    %% =================================================================
    %% SALVAMENTO DOS RESULTADOS
    %% =================================================================

    fprintf('\n=====================================\n');
    fprintf('SALVANDO RESULTADOS\n');
    fprintf('=====================================\n\n');

    % Estruturar dados para salvamento
    resultados.parametros.h = h;
    resultados.parametros.delta = delta;
    resultados.parametros.tol = tol;
    resultados.parametros.m1 = m1;
    resultados.parametros.m2 = m2;
    resultados.parametros.k1 = k1;
    resultados.parametros.k2 = k2;
    resultados.parametros.b = b;

    % Sistema baseado em genSaveDataEx12
    resultados.sistema.baseadoEm = 'genSaveDataEx12';
    resultados.sistema.estrutura = 'massa-mola-amortecedor 4x4';
    resultados.sistema.controle = 'entrada única na massa 2';
    resultados.sistema.perturbacao = 'entrada única na massa 1';

    % Ganhos obtidos
    if sucesso_int_nom
        resultados.ganhos.nominal.intervalar.K = K_int_nom;
        resultados.ganhos.nominal.intervalar.gamma = gamma_int_nom;
        resultados.ganhos.nominal.intervalar.tempo = tempo_int_nom;
    end

    if sucesso_poly_nom
        resultados.ganhos.nominal.politopica.K = K_poly_nom;
        resultados.ganhos.nominal.politopica.gamma = gamma_poly_nom;
        resultados.ganhos.nominal.politopica.tempo = tempo_poly_nom;
    end

    if sucesso_nom
        resultados.ganhos.nominal.classica.K = K_nom;
        resultados.ganhos.nominal.classica.gamma = gamma_nom;
        resultados.ganhos.nominal.classica.tempo = tempo_nom;
    end

    if sucesso_int_rob
        resultados.ganhos.robusto.intervalar.K = K_int_rob;
        resultados.ganhos.robusto.intervalar.gamma = gamma_int_rob;
        resultados.ganhos.robusto.intervalar.tempo = tempo_int_rob;
    end

    if sucesso_poly_rob
        resultados.ganhos.robusto.politopica.K = K_poly_rob;
        resultados.ganhos.robusto.politopica.gamma = gamma_poly_rob;
        resultados.ganhos.robusto.politopica.tempo = tempo_poly_rob;
    end

    if sucesso_central
        resultados.ganhos.robusto.central.K = K_central;
        resultados.ganhos.robusto.central.gamma = gamma_central;
        resultados.ganhos.robusto.central.tempo = tempo_central;
    end

    % Resultados das sínteses contínuas
    if sucesso_cont_int_rob && ~isempty(K_cont_int_rob)
        resultados.ganhos.continuo.intervalar.K = K_cont_int_rob;
        resultados.ganhos.continuo.intervalar.gamma = gamma_cont_int_rob;
        resultados.ganhos.continuo.intervalar.tempo = tempo_cont_int_rob;
    end

    if sucesso_cont_poly_rob && ~isempty(K_cont_poly_rob)
        resultados.ganhos.continuo.politopica.K = K_cont_poly_rob;
        resultados.ganhos.continuo.politopica.gamma = gamma_cont_poly_rob;
        resultados.ganhos.continuo.politopica.tempo = tempo_cont_poly_rob;
    end

    % Resultados das sínteses contínuas alternativas
    if sucesso_cont_int_alt && ~isempty(K_cont_int_alt)
        resultados.ganhos.continuo_alternativo.intervalar.K = K_cont_int_alt;
        resultados.ganhos.continuo_alternativo.intervalar.gamma = gamma_cont_int_alt;
        resultados.ganhos.continuo_alternativo.intervalar.tempo = tempo_cont_int_alt;
    end

    if sucesso_cont_poly_alt && ~isempty(K_cont_poly_alt)
        resultados.ganhos.continuo_alternativo.politopica.K = K_cont_poly_alt;
        resultados.ganhos.continuo_alternativo.politopica.gamma = gamma_cont_poly_alt;
        resultados.ganhos.continuo_alternativo.politopica.tempo = tempo_cont_poly_alt;
    end

    %% =================================================================
    %% ETAPA 4: ANÁLISE COMPLETA DOS GANHOS ROBUSTOS COM MÚLTIPLAS FUNÇÕES
    %% =================================================================

    fprintf('=====================================\n');
    fprintf('ETAPA 4: ANÁLISE COMPLETA DOS GANHOS (MÚLTIPLAS FUNÇÕES DE PROVA)\n');
    fprintf('=====================================\n');
    fprintf('Testando todos os ganhos com TODAS as funções de análise disponíveis\n\n');

    % Adicionar todos os caminhos das funções de análise
    addpath('HInf - Análise Politópico/funcoes');
    addpath('HInf - Análise - Intervalar/funcoes');
    addpath('HInf - Análise - Intervalar/funcoes/AnaliseSemInt');

    % Lista de todas as funções de análise disponíveis
    funcoes_analise_poly = {
        'estHInfAnaPolyLMILab',
        'estHInfAnaPolyLMILabOriginal',
        'estHInfAnaPolyLMILabAnal2'
    };

    funcoes_analise_intervalar = {
        'valEstHInfLMILab',
        'valEstHInfLMILabInt',
        'valEstHInfLMILabSemInt',
        'valEstHInfInt',
        'valEstHInfSemInt'
    };

    % Funções adicionais de análise híbrida robusta encontradas
    funcoes_analise_hibrida = {
        'estHInfAnaPoly',
        'verificaEstSisHib',
        'normaSistemaContinuo'
    };

    % Preparar dimensões e matrizes caligráficas (comum para todas as análises)
    nx = size(A_central, 1);
    nu = size(B_central, 2);
    nw = size(E_central, 2);

    ACal_base = [A_central B_central ; zeros(nu, nx) zeros(nu, nu)];
    ECal_base = [E_central ; zeros(nu, nw)];
    CCal_base = [C_nom_central D_nom_central];

    %% ANÁLISE COMPLETA 1: Ganho Nominal Clássico (Método 3)
    if sucesso_nom && ~isempty(K_nom)
        fprintf('=====================================\n');
        fprintf('ANÁLISE COMPLETA 1: GANHO NOMINAL CLÁSSICO\n');
        fprintf('=====================================\n');
        fprintf('Testando ganho K = [%.6f %.6f %.6f %.6f] (γ original = %.6f)\n\n', ...
            K_nom(1), K_nom(2), K_nom(3), K_nom(4), gamma_nom);

        KCal_nominal = [eye(nx) zeros(nx, nu); K_nom zeros(nu)];

        % Teste com funções politópicas
        fprintf('--- TESTE COM FUNÇÕES POLITÓPICAS ---\n');
        for f = 1:length(funcoes_analise_poly)
            func_name = funcoes_analise_poly{f};
            fprintf('%d. Testando %s: ', f, func_name);

            if exist(func_name, 'file')
                try
                    % Preparar politopo com matrizes caligráficas corretas para análise
                    poly_analise.APoly = {};
                    poly_analise.EPoly = {};
                    poly_analise.CPoly = {};

                    % Usar as mesmas matrizes caligráficas que funcionam com valEstHInfLMILab
                    for v = 1:length(poly_rob.APoly)
                        % Sistema do vértice v
                        A_v = poly_rob.APoly{v};
                        B_v = poly_rob.BPoly{v};
                        E_v = poly_rob.EPoly{v};
                        C_v = poly_rob.CPoly{v};
                        D_v = poly_rob.DPoly{v};

                        % Construir matrizes caligráficas para este vértice
                        poly_analise.APoly{v} = [A_v B_v ; zeros(nu, nx) zeros(nu, nu)];
                        poly_analise.EPoly{v} = [E_v ; zeros(nu, nw)];
                        poly_analise.CPoly{v} = [C_v D_v];
                    end

                    tic;
                    resultado = feval(func_name, poly_analise, KCal_nominal, h, delta, tol);
                    tempo = toc;

                    if isfield(resultado, 'gamma') && isfinite(resultado.gamma) && resultado.gamma > 0
                        fprintf('✓ SUCESSO - γ = %.6f (degradação = %.2f%%) [%.4fs]\n', ...
                            resultado.gamma, (resultado.gamma - gamma_nom)/gamma_nom*100, tempo);

                        % Salvar melhor resultado
                        if ~isfield(resultados, 'analise_ganhos') || ~isfield(resultados.analise_ganhos, 'nominal_classico') || ...
                           ~isfield(resultados.analise_ganhos.nominal_classico, 'gamma_politopico')
                            resultados.analise_ganhos.nominal_classico.K = K_nom;
                            resultados.analise_ganhos.nominal_classico.gamma_original = gamma_nom;
                            resultados.analise_ganhos.nominal_classico.gamma_politopico = resultado.gamma;
                            resultados.analise_ganhos.nominal_classico.degradacao_percentual = (resultado.gamma - gamma_nom)/gamma_nom*100;
                            resultados.analise_ganhos.nominal_classico.funcao_usada = func_name;
                            resultados.analise_ganhos.nominal_classico.tempo_analise = tempo;
                        end
                    else
                        fprintf('✗ Falhou - γ inválido\n');
                    end
                catch ME
                    fprintf('✗ Erro - %s\n', ME.message);
                end
            else
                fprintf('⚠ Função não encontrada\n');
            end
        end

        % Teste com funções intervalares
        fprintf('\n--- TESTE COM FUNÇÕES INTERVALARES ---\n');
        for f = 1:length(funcoes_analise_intervalar)
            func_name = funcoes_analise_intervalar{f};
            fprintf('%d. Testando %s: ', f, func_name);

            if exist(func_name, 'file')
                try
                    tic;
                    resultado = feval(func_name, ACal_base, ECal_base, CCal_base, KCal_nominal, h, delta, tol);
                    tempo = toc;

                    if isfield(resultado, 'gamma') && isfinite(resultado.gamma) && resultado.gamma > 0
                        fprintf('✓ SUCESSO - γ = %.6f (degradação = %.2f%%) [%.4fs]\n', ...
                            resultado.gamma, (resultado.gamma - gamma_nom)/gamma_nom*100, tempo);

                        % Salvar como análise intervalar
                        resultados.analise_ganhos.nominal_classico_intervalar.K = K_nom;
                        resultados.analise_ganhos.nominal_classico_intervalar.gamma_original = gamma_nom;
                        resultados.analise_ganhos.nominal_classico_intervalar.gamma_intervalar = resultado.gamma;
                        resultados.analise_ganhos.nominal_classico_intervalar.degradacao_percentual = (resultado.gamma - gamma_nom)/gamma_nom*100;
                        resultados.analise_ganhos.nominal_classico_intervalar.diferenca_percentual = (resultado.gamma - gamma_nom)/gamma_nom*100;
                        resultados.analise_ganhos.nominal_classico_intervalar.funcao_usada = func_name;
                        resultados.analise_ganhos.nominal_classico_intervalar.tempo_analise = tempo;
                        break; % Usar apenas o primeiro que funcionar
                    else
                        fprintf('✗ Falhou - γ inválido\n');
                    end
                catch ME
                    fprintf('✗ Erro - %s\n', ME.message);
                end
            else
                fprintf('⚠ Função não encontrada\n');
            end
        end

        % Teste com funções híbridas adicionais
        fprintf('\n--- TESTE COM FUNÇÕES HÍBRIDAS ROBUSTAS ADICIONAIS ---\n');
        for f = 1:length(funcoes_analise_hibrida)
            func_name = funcoes_analise_hibrida{f};
            fprintf('%d. Testando %s: ', f, func_name);

            if exist(func_name, 'file')
                try
                    tic;
                    if strcmp(func_name, 'estHInfAnaPoly')
                        % Esta função espera politopo
                        resultado = feval(func_name, poly_rob, KCal_nominal, h, delta, tol);
                    elseif strcmp(func_name, 'verificaEstSisHib')
                        % Esta função verifica apenas estabilidade
                        autovalor_max = feval(func_name, ACal_base, KCal_nominal, h);
                        fprintf('✓ ESTABILIDADE - λ_max = %.6f [%.4fs]\n', abs(autovalor_max), toc);

                        % Salvar resultado de estabilidade
                        resultados.analise_ganhos.nominal_classico_estabilidade.K = K_nom;
                        resultados.analise_ganhos.nominal_classico_estabilidade.autovalor_max = abs(autovalor_max);
                        resultados.analise_ganhos.nominal_classico_estabilidade.estavel = abs(autovalor_max) < 1;
                        resultados.analise_ganhos.nominal_classico_estabilidade.funcao_usada = func_name;
                        continue;
                    elseif strcmp(func_name, 'normaSistemaContinuo')
                        % Esta função calcula norma H∞ contínua
                        DCal_base = zeros(size(CCal_base,1), size(ECal_base,2)); % D para perturbação
                        resultado_norma = feval(func_name, ACal_base, ECal_base, CCal_base, DCal_base);
                        fprintf('✓ NORMA H∞ CONTÍNUA = %.6f [%.4fs]\n', resultado_norma.hInfNorm, toc);

                        % Salvar resultado de norma contínua
                        resultados.analise_ganhos.nominal_classico_continuo.K = K_nom;
                        resultados.analise_ganhos.nominal_classico_continuo.norma_hinf = resultado_norma.hInfNorm;
                        resultados.analise_ganhos.nominal_classico_continuo.freq_norma = resultado_norma.freqNorm;
                        resultados.analise_ganhos.nominal_classico_continuo.funcao_usada = func_name;
                        continue;
                    else
                        resultado = feval(func_name, ACal_base, ECal_base, CCal_base, KCal_nominal, h, delta, tol);
                    end
                    tempo = toc;

                    if isfield(resultado, 'gamma') && isfinite(resultado.gamma) && resultado.gamma > 0
                        fprintf('✓ SUCESSO - γ = %.6f (degradação = %.2f%%) [%.4fs]\n', ...
                            resultado.gamma, (resultado.gamma - gamma_nom)/gamma_nom*100, tempo);

                        % Salvar como análise híbrida adicional
                        campo_nome = sprintf('nominal_classico_hibrido_%s', strrep(func_name, 'EstH', 'est_h'));
                        resultados.analise_ganhos.(campo_nome).K = K_nom;
                        resultados.analise_ganhos.(campo_nome).gamma_original = gamma_nom;
                        resultados.analise_ganhos.(campo_nome).gamma_hibrido = resultado.gamma;
                        resultados.analise_ganhos.(campo_nome).degradacao_percentual = (resultado.gamma - gamma_nom)/gamma_nom*100;
                        resultados.analise_ganhos.(campo_nome).funcao_usada = func_name;
                        resultados.analise_ganhos.(campo_nome).tempo_analise = tempo;
                    else
                        fprintf('✗ Falhou - γ inválido\n');
                    end
                catch ME
                    fprintf('✗ Erro - %s\n', ME.message);
                end
            else
                fprintf('⚠ Função não encontrada\n');
            end
        end
        fprintf('\n');
    end

    %% ANÁLISE COMPLETA 2: Ganho Contínuo Robusto (Método 7)
    if sucesso_cont_int_rob && ~isempty(K_cont_int_rob)
        fprintf('=====================================\n');
        fprintf('ANÁLISE COMPLETA 2: GANHO CONTÍNUO ROBUSTO\n');
        fprintf('=====================================\n');
        fprintf('Testando ganho K = [%.6f %.6f %.6f %.6f] (γ original = %.6f)\n\n', ...
            K_cont_int_rob(1), K_cont_int_rob(2), K_cont_int_rob(3), K_cont_int_rob(4), gamma_cont_int_rob);

        KCal_continuo = [eye(nx) zeros(nx, nu); K_cont_int_rob zeros(nu)];

        % Teste com funções politópicas
        fprintf('--- TESTE COM FUNÇÕES POLITÓPICAS ---\n');
        for f = 1:length(funcoes_analise_poly)
            func_name = funcoes_analise_poly{f};
            fprintf('%d. Testando %s: ', f, func_name);

            if exist(func_name, 'file')
                try
                    % Preparar politopo com matrizes caligráficas corretas para análise
                    poly_analise.APoly = {};
                    poly_analise.EPoly = {};
                    poly_analise.CPoly = {};

                    % Usar as mesmas matrizes caligráficas que funcionam com valEstHInfLMILab
                    for v = 1:length(poly_rob.APoly)
                        % Sistema do vértice v
                        A_v = poly_rob.APoly{v};
                        B_v = poly_rob.BPoly{v};
                        E_v = poly_rob.EPoly{v};
                        C_v = poly_rob.CPoly{v};
                        D_v = poly_rob.DPoly{v};

                        % Construir matrizes caligráficas para este vértice
                        poly_analise.APoly{v} = [A_v B_v ; zeros(nu, nx) zeros(nu, nu)];
                        poly_analise.EPoly{v} = [E_v ; zeros(nu, nw)];
                        poly_analise.CPoly{v} = [C_v D_v];
                    end

                    tic;
                    resultado = feval(func_name, poly_analise, KCal_continuo, h, delta, tol);
                    tempo = toc;

                    if isfield(resultado, 'gamma') && isfinite(resultado.gamma) && resultado.gamma > 0
                        fprintf('✓ SUCESSO - γ = %.6f (diferença = %.2f%%) [%.4fs]\n', ...
                            resultado.gamma, (resultado.gamma - gamma_cont_int_rob)/gamma_cont_int_rob*100, tempo);

                        % Salvar melhor resultado
                        if ~isfield(resultados, 'analise_ganhos') || ~isfield(resultados.analise_ganhos, 'continuo_robusto') || ...
                           ~isfield(resultados.analise_ganhos.continuo_robusto, 'gamma_politopico_hibrido')
                            resultados.analise_ganhos.continuo_robusto.K = K_cont_int_rob;
                            resultados.analise_ganhos.continuo_robusto.gamma_original = gamma_cont_int_rob;
                            resultados.analise_ganhos.continuo_robusto.gamma_politopico_hibrido = resultado.gamma;
                            resultados.analise_ganhos.continuo_robusto.diferenca_percentual = (resultado.gamma - gamma_cont_int_rob)/gamma_cont_int_rob*100;
                            resultados.analise_ganhos.continuo_robusto.funcao_usada = func_name;
                            resultados.analise_ganhos.continuo_robusto.tempo_analise = tempo;
                        end
                    else
                        fprintf('✗ Falhou - γ inválido\n');
                    end
                catch ME
                    fprintf('✗ Erro - %s\n', ME.message);
                end
            else
                fprintf('⚠ Função não encontrada\n');
            end
        end

        % Teste com funções intervalares
        fprintf('\n--- TESTE COM FUNÇÕES INTERVALARES ---\n');
        for f = 1:length(funcoes_analise_intervalar)
            func_name = funcoes_analise_intervalar{f};
            fprintf('%d. Testando %s: ', f, func_name);

            if exist(func_name, 'file')
                try
                    tic;
                    resultado = feval(func_name, ACal_base, ECal_base, CCal_base, KCal_continuo, h, delta, tol);
                    tempo = toc;

                    if isfield(resultado, 'gamma') && isfinite(resultado.gamma) && resultado.gamma > 0
                        fprintf('✓ SUCESSO - γ = %.6f (diferença = %.2f%%) [%.4fs]\n', ...
                            resultado.gamma, (resultado.gamma - gamma_cont_int_rob)/gamma_cont_int_rob*100, tempo);

                        % Salvar como análise intervalar
                        resultados.analise_ganhos.continuo_robusto_intervalar.K = K_cont_int_rob;
                        resultados.analise_ganhos.continuo_robusto_intervalar.gamma_original = gamma_cont_int_rob;
                        resultados.analise_ganhos.continuo_robusto_intervalar.gamma_intervalar = resultado.gamma;
                        resultados.analise_ganhos.continuo_robusto_intervalar.diferenca_percentual = (resultado.gamma - gamma_cont_int_rob)/gamma_cont_int_rob*100;
                        resultados.analise_ganhos.continuo_robusto_intervalar.degradacao_percentual = (resultado.gamma - gamma_cont_int_rob)/gamma_cont_int_rob*100;
                        resultados.analise_ganhos.continuo_robusto_intervalar.funcao_usada = func_name;
                        resultados.analise_ganhos.continuo_robusto_intervalar.tempo_analise = tempo;
                        % break; % Usar apenas o primeiro que funcionar
                    else
                        fprintf('✗ Falhou - γ inválido\n');
                    end
                catch ME
                    fprintf('✗ Erro - %s\n', ME.message);
                end
            else
                fprintf('⚠ Função não encontrada\n');
            end
        end

        % Teste com funções híbridas adicionais para ganho contínuo
        fprintf('\n--- TESTE COM FUNÇÕES HÍBRIDAS ROBUSTAS ADICIONAIS ---\n');
        for f = 1:length(funcoes_analise_hibrida)
            func_name = funcoes_analise_hibrida{f};
            fprintf('%d. Testando %s: ', f, func_name);

            if exist(func_name, 'file')
                try
                    tic;
                    if strcmp(func_name, 'estHInfAnaPoly')
                        % Esta função espera politopo
                        resultado = feval(func_name, poly_rob, KCal_continuo, h, delta, tol);
                    elseif strcmp(func_name, 'verificaEstSisHib')
                        % Esta função verifica apenas estabilidade
                        autovalor_max = feval(func_name, ACal_base, KCal_continuo, h);
                        fprintf('✓ ESTABILIDADE - λ_max = %.6f [%.4fs]\n', abs(autovalor_max), toc);

                        % Salvar resultado de estabilidade
                        resultados.analise_ganhos.continuo_robusto_estabilidade.K = K_cont_int_rob;
                        resultados.analise_ganhos.continuo_robusto_estabilidade.autovalor_max = abs(autovalor_max);
                        resultados.analise_ganhos.continuo_robusto_estabilidade.estavel = abs(autovalor_max) < 1;
                        resultados.analise_ganhos.continuo_robusto_estabilidade.funcao_usada = func_name;
                        continue;
                    elseif strcmp(func_name, 'normaSistemaContinuo')
                        % Esta função calcula norma H∞ contínua
                        DCal_base = zeros(size(CCal_base,1), size(ECal_base,2)); % D para perturbação
                        resultado_norma = feval(func_name, ACal_base, ECal_base, CCal_base, DCal_base);
                        fprintf('✓ NORMA H∞ CONTÍNUA = %.6f [%.4fs]\n', resultado_norma.hInfNorm, toc);

                        % Salvar resultado de norma contínua
                        resultados.analise_ganhos.continuo_robusto_continuo.K = K_cont_int_rob;
                        resultados.analise_ganhos.continuo_robusto_continuo.norma_hinf = resultado_norma.hInfNorm;
                        resultados.analise_ganhos.continuo_robusto_continuo.freq_norma = resultado_norma.freqNorm;
                        resultados.analise_ganhos.continuo_robusto_continuo.funcao_usada = func_name;
                        continue;
                    else
                        resultado = feval(func_name, ACal_base, ECal_base, CCal_base, KCal_continuo, h, delta, tol);
                    end
                    tempo = toc;

                    if isfield(resultado, 'gamma') && isfinite(resultado.gamma) && resultado.gamma > 0
                        fprintf('✓ SUCESSO - γ = %.6f (diferença = %.2f%%) [%.4fs]\n', ...
                            resultado.gamma, (resultado.gamma - gamma_cont_int_rob)/gamma_cont_int_rob*100, tempo);

                        % Salvar como análise híbrida adicional
                        campo_nome = sprintf('continuo_robusto_hibrido_%s', strrep(func_name, 'EstH', 'est_h'));
                        resultados.analise_ganhos.(campo_nome).K = K_cont_int_rob;
                        resultados.analise_ganhos.(campo_nome).gamma_original = gamma_cont_int_rob;
                        resultados.analise_ganhos.(campo_nome).gamma_hibrido = resultado.gamma;
                        resultados.analise_ganhos.(campo_nome).diferenca_percentual = (resultado.gamma - gamma_cont_int_rob)/gamma_cont_int_rob*100;
                        resultados.analise_ganhos.(campo_nome).funcao_usada = func_name;
                        resultados.analise_ganhos.(campo_nome).tempo_analise = tempo;
                    else
                        fprintf('✗ Falhou - γ inválido\n');
                    end
                catch ME
                    fprintf('✗ Erro - %s\n', ME.message);
                end
            else
                fprintf('⚠ Função não encontrada\n');
            end
        end

        fprintf('\n');
    end

    %% ANÁLISE ADICIONAL: Teste de todos os outros ganhos disponíveis
    fprintf('=====================================\n');
    fprintf('ANÁLISE ADICIONAL: TODOS OS GANHOS SINTETIZADOS\n');
    fprintf('=====================================\n');

    ganhos_disponiveis = {};
    nomes_ganhos = {};
    gammas_originais = {};

    % Coletar todos os ganhos disponíveis
    if sucesso_int_nom && ~isempty(K_int_nom)
        ganhos_disponiveis{end+1} = K_int_nom;
        nomes_ganhos{end+1} = 'Intervalar Nominal';
        gammas_originais{end+1} = gamma_int_nom;
    end
    if sucesso_poly_nom && ~isempty(K_poly_nom)
        ganhos_disponiveis{end+1} = K_poly_nom;
        nomes_ganhos{end+1} = 'Politópico Nominal';
        gammas_originais{end+1} = gamma_poly_nom;
    end
    if sucesso_int_rob && ~isempty(K_int_rob)
        ganhos_disponiveis{end+1} = K_int_rob;
        nomes_ganhos{end+1} = 'Intervalar Robusto';
        gammas_originais{end+1} = gamma_int_rob;
    end
    if sucesso_poly_rob && ~isempty(K_poly_rob)
        ganhos_disponiveis{end+1} = K_poly_rob;
        nomes_ganhos{end+1} = 'Politópico Robusto';
        gammas_originais{end+1} = gamma_poly_rob;
    end
    if sucesso_central && ~isempty(K_central)
        ganhos_disponiveis{end+1} = K_central;
        nomes_ganhos{end+1} = 'Nominal Central';
        gammas_originais{end+1} = gamma_central;
    end
    if sucesso_cont_poly_rob && ~isempty(K_cont_poly_rob)
        ganhos_disponiveis{end+1} = K_cont_poly_rob;
        nomes_ganhos{end+1} = 'Contínuo Politópico';
        gammas_originais{end+1} = gamma_cont_poly_rob;
    end

    % Testar cada ganho com a primeira função que funcionar
    for g = 1:length(ganhos_disponiveis)
        fprintf('--- TESTE DO GANHO: %s ---\n', nomes_ganhos{g});
        K_teste = ganhos_disponiveis{g};
        gamma_original = gammas_originais{g};

        KCal_teste = [eye(nx) zeros(nx, nu); K_teste zeros(nu)];

        fprintf('Ganho K = [%.6f %.6f %.6f %.6f] (γ original = %.6f)\n', ...
            K_teste(1), K_teste(2), K_teste(3), K_teste(4), gamma_original);

        % Tentar com primeira função politópica que funcionar
        sucesso_teste = false;
        for f = 1:length(funcoes_analise_poly)
            func_name = funcoes_analise_poly{f};
            if exist(func_name, 'file')
                try
                    % Preparar politopo com matrizes caligráficas corretas
                    poly_analise.APoly = {};
                    poly_analise.EPoly = {};
                    poly_analise.CPoly = {};

                    for v = 1:length(poly_rob.APoly)
                        A_v = poly_rob.APoly{v};
                        B_v = poly_rob.BPoly{v};
                        E_v = poly_rob.EPoly{v};
                        C_v = poly_rob.CPoly{v};
                        D_v = poly_rob.DPoly{v};

                        poly_analise.APoly{v} = [A_v B_v ; zeros(nu, nx) zeros(nu, nu)];
                        poly_analise.EPoly{v} = [E_v ; zeros(nu, nw)];
                        poly_analise.CPoly{v} = [C_v D_v];
                    end

                    resultado = feval(func_name, poly_analise, KCal_teste, h, delta, tol);
                    if isfield(resultado, 'gamma') && isfinite(resultado.gamma) && resultado.gamma > 0
                        fprintf('  ✓ %s: γ = %.6f (diferença = %.2f%%)\n', ...
                            func_name, resultado.gamma, (resultado.gamma - gamma_original)/gamma_original*100);

                        % Salvar resultado
                        campo_nome = strrep(lower(nomes_ganhos{g}), ' ', '_');
                        resultados.analise_ganhos.todos_ganhos.(campo_nome).K = K_teste;
                        resultados.analise_ganhos.todos_ganhos.(campo_nome).gamma_original = gamma_original;
                        resultados.analise_ganhos.todos_ganhos.(campo_nome).gamma_politopico = resultado.gamma;
                        resultados.analise_ganhos.todos_ganhos.(campo_nome).diferenca_percentual = (resultado.gamma - gamma_original)/gamma_original*100;
                        resultados.analise_ganhos.todos_ganhos.(campo_nome).funcao_usada = func_name;

                        sucesso_teste = true;
                        break;
                    end
                catch
                    % Continua para próxima função
                end
            end
        end

        if ~sucesso_teste
            fprintf('  ✗ Todos os testes falharam para este ganho\n');
        end
        fprintf('\n');
    end

    %% RESUMO FINAL COMPLETO
    fprintf('=====================================\n');
    fprintf('RESUMO FINAL - TODAS AS ANÁLISES\n');
    fprintf('=====================================\n');

    if isfield(resultados, 'analise_ganhos')
        campos = fieldnames(resultados.analise_ganhos);
        fprintf('Total de análises realizadas: %d\n\n', length(campos));

        for c = 1:length(campos)
            if isstruct(resultados.analise_ganhos.(campos{c}))
                analise = resultados.analise_ganhos.(campos{c});
                fprintf('📊 %s:\n', upper(strrep(campos{c}, '_', ' ')));

                if isfield(analise, 'gamma_original') && isfield(analise, 'K')
                    fprintf('    Ganho K: [%.6f %.6f %.6f %.6f]\n', analise.K(1), analise.K(2), analise.K(3), analise.K(4));
                    fprintf('    γ original: %.6f\n', analise.gamma_original);

                    if isfield(analise, 'gamma_politopico')
                        fprintf('    γ politópico: %.6f (degradação: %.2f%%)\n', ...
                            analise.gamma_politopico, analise.degradacao_percentual);
                    end
                    if isfield(analise, 'gamma_intervalar')
                        if isfield(analise, 'degradacao_percentual')
                            fprintf('    γ intervalar: %.6f (degradação: %.2f%%)\n', ...
                                analise.gamma_intervalar, analise.degradacao_percentual);
                        else
                            fprintf('    γ intervalar: %.6f\n', analise.gamma_intervalar);
                        end
                    end
                    if isfield(analise, 'gamma_politopico_hibrido')
                        fprintf('    γ politópico híbrido: %.6f (diferença: %.2f%%)\n', ...
                            analise.gamma_politopico_hibrido, analise.diferenca_percentual);
                    end
                    if isfield(analise, 'funcao_usada')
                        fprintf('    Função usada: %s\n', analise.funcao_usada);
                    end
                end
                fprintf('\n');
            end
        end
    else
        fprintf('❌ Nenhuma análise foi bem-sucedida!\n\n');
    end

    % Salvar workspace
    save('resultados_completos_massa_mola.mat', 'resultados');

    fprintf('Resultados salvos em: resultados_completos_massa_mola.mat\n\n');
    fprintf('=== SÍNTESE COMPLETA FINALIZADA COM SUCESSO ===\n');
    fprintf('Sistema baseado na estrutura do genSaveDataEx12\n');
    fprintf('10 métodos de síntese + 2 análises robustas implementados:\n');
    fprintf('  - Métodos 1-3: Sínteses nominais\n');
    fprintf('  - Métodos 4-6: Sínteses robustas (amostrado)\n');
    fprintf('  - Métodos 7-8: Sínteses robustas (contínuo - LMILab)\n');
    fprintf('  - Métodos 9-10: Sínteses robustas (contínuo - alternativo)\n');
    fprintf('  - ANÁLISE 1: Ganho nominal em sistema politópico incerto\n');
    fprintf('  - ANÁLISE 2: Ganho contínuo robusto em análise politópica híbrida\n\n');

end