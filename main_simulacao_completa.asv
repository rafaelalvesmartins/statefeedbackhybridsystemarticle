function main_simulacao_completa()
%   MAIN_SIMULACAO_COMPLETA - Resposta Espec√≠fica ao Revisor
%
%   Compara√ß√£o focada conforme solicita√ß√£o do revisor:
%   b) Compara√ß√£o entre representa√ß√µes norm-bounded e polit√≥picas da incerteza
%
%   An√°lises inclu√≠das:
%   1. Compara√ß√£o entre controladores H‚àû com incertezas intervalares vs polit√≥picas
%   2. Performance de controlador H‚àû nominal amostrado em cen√°rios incertos
%   3. Performance com implementa√ß√£o amostrada de controlador H‚àû cont√≠nuo incerto
%   4. Signific√¢ncia da presen√ßa de incertezas na implementa√ß√£o amostrada
%
%   Autor: Resposta ao Revisor
%   Data: 2025

    %% =================================================================
    %% 1. CONFIGURA√á√ÉO E CARREGAMENTO - RESPOSTA AO REVISOR
    %% =================================================================

    clear; clc; close all;

    fprintf('==================================================================================\n');
    fprintf('                      RESPOSTA ESPEC√çFICA AO REVISOR\n');
    fprintf('     Compara√ß√£o entre norm-bounded e polit√≥pico + an√°lise de incertezas\n');
    fprintf('==================================================================================\n\n');

    fprintf('Iniciando an√°lise focada conforme solicita√ß√£o do revisor...\n');
    fprintf('Data/Hora: %s\n\n', datestr(now, 'dd/mm/yyyy HH:MM:SS'));

    % Adicionar caminhos necess√°rios
    setup_paths();
    fprintf('\n');
    addpath('funcoes');
    addpath('functions');
    addpath('functions/Poly');
    addpath('HInf - An√°lise - Intervalar/funcoes');
    addpath('HInf - An√°lise - Intervalar/funcoes/Diversas');

    % Carregar resultados das s√≠nteses
    fprintf('Carregando controladores sintetizados...\n');
    try
        load('resultados_completos_massa_mola.mat', 'resultados');
        fprintf('‚úì Controladores carregados com sucesso!\n');
        fprintf('  Sistema: h=%.4f, delta=%.6f\n\n', ...
            resultados.parametros.h, resultados.parametros.delta);
    catch ME
        error('ERRO: Execute primeiro main_massa_mola_completo.m para gerar os controladores');
    end

    %% =================================================================
    %% 2. EXTRA√á√ÉO DOS CONTROLADORES ESPEC√çFICOS PARA O REVISOR
    %% =================================================================

    fprintf('Extraindo controladores espec√≠ficos conforme solicita√ß√£o do revisor...\n\n');

    % CONTROLADOR 1: H‚àû Nominal Sampled-Time (para teste em cen√°rios incertos)
    if isfield(resultados.ganhos, 'nominal') && isfield(resultados.ganhos.nominal, 'classica')
        K_nominal_sampled = resultados.ganhos.nominal.classica.K;
        gamma_nominal_sampled = resultados.ganhos.nominal.classica.gamma;
        fprintf('‚úì CONTROLADOR 1: H‚àû Nominal Amostrado\n');
        fprintf('    K = [%.6f %.6f %.6f %.6f], Œ≥ = %.6f\n', K_nominal_sampled, gamma_nominal_sampled);
    else
        error('Controlador H‚àû nominal amostrado n√£o encontrado!');
    end

    % CONTROLADOR 2: H‚àû Robusto Intervalar (norm-bounded uncertainty)
    if isfield(resultados.ganhos, 'robusto') && isfield(resultados.ganhos.robusto, 'intervalar')
        K_robust_interval = resultados.ganhos.robusto.intervalar.K;
        gamma_robust_interval = resultados.ganhos.robusto.intervalar.gamma;
        fprintf('‚úì CONTROLADOR 2: H‚àû Robusto Intervalar (norm-bounded)\n');
        fprintf('    K = [%.6f %.6f %.6f %.6f], Œ≥ = %.6f\n', K_robust_interval, gamma_robust_interval);
    else
        error('Controlador H‚àû robusto intervalar n√£o encontrado!');
    end

    % CONTROLADOR 3: H‚àû Robusto Polit√≥pico (polytopic uncertainty)
    if isfield(resultados.ganhos, 'robusto') && isfield(resultados.ganhos.robusto, 'politopica')
        K_robust_polytopic = resultados.ganhos.robusto.politopica.K;
        gamma_robust_polytopic = resultados.ganhos.robusto.politopica.gamma;
        fprintf('‚úì CONTROLADOR 3: H‚àû Robusto Polit√≥pico (polytopic)\n');
        fprintf('    K = [%.6f %.6f %.6f %.6f], Œ≥ = %.6f\n', K_robust_polytopic, gamma_robust_polytopic);
    else
        error('Controlador H‚àû robusto polit√≥pico n√£o encontrado!');
    end

    % CONTROLADOR 4: H‚àû Cont√≠nuo Incerto (implementa√ß√£o amostrada)
    if isfield(resultados.ganhos, 'continuo') && isfield(resultados.ganhos.continuo, 'intervalar')
        K_continuous_sampled = resultados.ganhos.continuo.intervalar.K;
        gamma_continuous_sampled = resultados.ganhos.continuo.intervalar.gamma;
        fprintf('‚úì CONTROLADOR 4: H‚àû Cont√≠nuo Incerto (implementa√ß√£o amostrada)\n');
        fprintf('    K = [%.6f %.6f %.6f %.6f], Œ≥ = %.6f\n', K_continuous_sampled, gamma_continuous_sampled);
    else
        error('Controlador H‚àû cont√≠nuo incerto n√£o encontrado!');
    end

    fprintf('\n‚úì Todos os 4 controladores necess√°rios foram encontrados!\n\n');

    %% =================================================================
    %% 3. PREPARA√á√ÉO DO SISTEMA COM POLITOPO PARA SIMULA√á√ÉO AMOSTRADA
    %% =================================================================

    fprintf('Preparando sistema polit√≥pico para simula√ß√£o amostrada correta...\n');

    % Par√¢metros do sistema
    m1 = resultados.parametros.m1;
    m2 = resultados.parametros.m2;
    k1 = resultados.parametros.k1;
    k2 = resultados.parametros.k2;
    b = resultados.parametros.b;
    h = resultados.parametros.h;
    delta = resultados.parametros.delta;
    tol = 1e-6;

    fprintf('Sistema base: m1=%.1f, m2=%.1f, k1=%.0f, k2=%.0f, b=%.2f\n', m1, m2, k1, k2, b);
    fprintf('Par√¢metros: h=%.4f, delta=%.6f, tol=%.0e\n', h, delta, tol);

    % Gerar politopo com incertezas conforme genSaveDataEx12
    % Incertezas: k2 ¬±2%, b ¬±5%
    k2_vals = [k2*0.98, k2*1.02];  % k2 com ¬±2%
    b_vals = [b*0.95, b*1.05];      % b com ¬±5%

    idx = 0;
    sysPolyCont = {};

    fprintf('Gerando v√©rtices do politopo:\n');
    for i = 1:length(k2_vals)
        for j = 1:length(b_vals)
            idx = idx + 1;

            % Sistema para este v√©rtice
            A_vertex = [0                                    0                   1                    0;
                        0                                    0                   0                    1;
                        (-k2_vals(i)-k1)/m1                 k2_vals(i)/m1      -b_vals(j)/m1        b_vals(j)/m1;
                        k2_vals(i)/m2                       -k2_vals(i)/m2      b_vals(j)/m2        -b_vals(j)/m2];

            sysPolyCont{idx}.A = A_vertex;
            sysPolyCont{idx}.B = [0; 0; 0; 1/m2];           % Entrada de controle
            sysPolyCont{idx}.E = [0; 0; 1/m1; 0];           % Entrada de perturba√ß√£o
            sysPolyCont{idx}.C = [0 10 0 0; 0 0 0 1; 0 0 0 0];  % Sa√≠das conforme genSaveDataEx12
            sysPolyCont{idx}.D = [0; 0; 1];                 % Feedthrough
            sysPolyCont{idx}.D1 = [0; 0; 0];                % Feedthrough perturba√ß√£o

            fprintf('  V√©rtice %d: k2=%.3f, b=%.4f\n', idx, k2_vals(i), b_vals(j));
        end
    end

    % Preparar estrutura combPoly para simulatesSampledInput
    combPoly = struct();
    for i = 1:idx
        combPoly.A.alphaVecs{i} = i;
        combPoly.A.polytopicMatrices{i} = sysPolyCont{i}.A;

        combPoly.B.alphaVecs{i} = i;
        combPoly.B.polytopicMatrices{i} = sysPolyCont{i}.B;

        combPoly.E.alphaVecs{i} = i;
        combPoly.E.polytopicMatrices{i} = sysPolyCont{i}.E;

        combPoly.C.alphaVecs{i} = i;
        combPoly.C.polytopicMatrices{i} = sysPolyCont{i}.C;

        combPoly.D.alphaVecs{i} = i;
        combPoly.D.polytopicMatrices{i} = sysPolyCont{i}.D;

        combPoly.D1.alphaVecs{i} = i;
        combPoly.D1.polytopicMatrices{i} = sysPolyCont{i}.D1;
    end

    fprintf('‚úì Politopo preparado: %d v√©rtices para simula√ß√£o amostrada\n\n', idx);

    %% =================================================================
    %% 4. SIMULA√á√ïES AMOSTRADAS CONFORME SOLICITA√á√ÉO DO REVISOR
    %% =================================================================

    fprintf('==================================================================================\n');
    fprintf('       EXECUTANDO SIMULA√á√ïES AMOSTRADAS - RESPOSTA AO REVISOR\n');
    fprintf('==================================================================================\n\n');

    % Controladores para an√°lise
    nomes_controladores = {
        'H‚àû Nominal Sampled';
        'H‚àû Robust Interval';
        'H‚àû Robust Polytopic';
        'H‚àû Continuous Sampled'
    };

    controladores_K = {K_nominal_sampled; K_robust_interval; K_robust_polytopic; K_continuous_sampled};
    controladores_gamma = [gamma_nominal_sampled; gamma_robust_interval; gamma_robust_polytopic; gamma_continuous_sampled];
    resultados_simulacao = cell(4, 1);

    % Par√¢metros de simula√ß√£o
    axisVector = [0 15 -0.5 1.5];  % Eixos para gr√°ficos

    fprintf('Executando simula√ß√µes amostradas usando LMIs adequadas...\n\n');

    % Configurar n√∫mero de simula√ß√µes Monte Carlo
    numSimulacoesMC = 100;
    fprintf('Configura√ß√£o Monte Carlo: %d simula√ß√µes aleat√≥rias (MESMOS sistemas para TODOS os controladores)\n\n');

    % GERAR SISTEMAS MONTE CARLO FIXOS (UMA √öNICA VEZ)
    fprintf('==================================================================================\n');
    fprintf('                    GERANDO SISTEMAS MONTE CARLO FIXOS\n');
    fprintf('==================================================================================\n\n');

    % Preparar par√¢metros do sistema para Monte Carlo
    parametros_sistema.m1 = m1;
    parametros_sistema.m2 = m2;
    parametros_sistema.k1 = k1;
    parametros_sistema.k2 = k2;
    parametros_sistema.b = b;

    % Gerar sistemas Monte Carlo fixos (com semente para reprodutibilidade)
    seed_monte_carlo = 12345;  % Semente fixa para reprodutibilidade
    sistemas_monte_carlo_fixos = gerarSistemasMonteCarloFixos(parametros_sistema, numSimulacoesMC, seed_monte_carlo);

    fprintf('‚úì %d sistemas Monte Carlo gerados e prontos para teste!\n\n', numSimulacoesMC);

    % SIMULA√á√ÉO 1: H‚àû Nominal Sampled-Time (MONTE CARLO)
    fprintf('--- SIMULA√á√ÉO 1: %s (Monte Carlo) ---\n', nomes_controladores{1});
    try
        imageName = sprintf('Sim1_HInf_Nominal_Sampled');
        flagIsPoly = false;  % Usa an√°lise intervalar
        tic;

        fprintf('    Testando controlador nos %d sistemas Monte Carlo fixos...\n', numSimulacoesMC);
        fprintf('    Par√¢metros: h=%.4f, delta=%.6f, tol=%.0e, flagIsPoly=%d\n', h, delta, tol, flagIsPoly);
        fprintf('    K = [%.6f %.6f %.6f %.6f]\n', K_nominal_sampled);

        output_sim1 = simulatesSampledInputMonteCarlo(sistemas_monte_carlo_fixos, h, K_nominal_sampled, imageName, axisVector, delta, tol, flagIsPoly);
        tempo_sim1 = toc;

        resultados_simulacao{1} = output_sim1;

        fprintf('  ‚úì Simula√ß√£o conclu√≠da: %.2f s\n', tempo_sim1);

        % Debug: mostrar todos os campos dispon√≠veis
        fprintf('    Debug - Campos dispon√≠veis: ');
        campos = fieldnames(output_sim1);
        for i = 1:length(campos)
            fprintf('%s ', campos{i});
        end
        fprintf('\n');

        % Verificar quais campos existem e reportar adequadamente
        if isfield(output_sim1, 'maxCost')
            fprintf('    Custo m√°ximo: %.6f\n', output_sim1.maxCost);
            fprintf('    Custo m√©dio: %.6f ¬± %.6f\n', output_sim1.meanCost, output_sim1.stdCost);
        else
            fprintf('    ‚ö† Campos de custo n√£o dispon√≠veis (poss√≠vel falha na simula√ß√£o)\n');
        end

        if isfield(output_sim1, 'gamma') && isfield(output_sim1.gamma, 'meanGamma')
            fprintf('    Œ≥ m√©dio (LMI): %.6f\n', output_sim1.gamma.meanGamma);
            fprintf('    Œ≥ m√°ximo (LMI): %.6f\n', output_sim1.gamma.maxGamma);
            fprintf('    Taxa sucesso LMI: %.1f%%\n', output_sim1.lmi_success_rate * 100);
            if isfield(output_sim1, 'sim_success_rate')
                fprintf('    Taxa sucesso simula√ß√£o: %.1f%%\n', output_sim1.sim_success_rate * 100);
            end
        else
            fprintf('    ‚ö† Campos de gamma n√£o dispon√≠veis\n');
        end

    catch ME
        fprintf('  ‚úó ERRO: %s\n', ME.message);
        fprintf('    Stack: %s\n', ME.stack(1).name);
        resultados_simulacao{1} = [];
    end
    fprintf('\n');

    % SIMULA√á√ÉO 2: H‚àû Robust Interval (norm-bounded) (MONTE CARLO)
    fprintf('--- SIMULA√á√ÉO 2: %s (Monte Carlo) ---\n', nomes_controladores{2});
    try
        imageName = sprintf('Sim2_HInf_Robust_Interval');
        flagIsPoly = false;  % Usa an√°lise intervalar
        tic;
        output_sim2 = simulatesSampledInputMonteCarlo(sistemas_monte_carlo_fixos, h, K_robust_interval, imageName, axisVector, delta, tol, flagIsPoly);
        tempo_sim2 = toc;

        resultados_simulacao{2} = output_sim2;

        fprintf('  ‚úì Simula√ß√£o conclu√≠da: %.2f s\n', tempo_sim2);

        if isfield(output_sim2, 'maxCost')
            fprintf('    Custo m√°ximo: %.6f\n', output_sim2.maxCost);
            fprintf('    Custo m√©dio: %.6f ¬± %.6f\n', output_sim2.meanCost, output_sim2.stdCost);
        else
            fprintf('    ‚ö† Campos de custo n√£o dispon√≠veis\n');
        end

        if isfield(output_sim2, 'gamma') && isfield(output_sim2.gamma, 'meanGamma')
            fprintf('    Œ≥ m√©dio (LMI): %.6f\n', output_sim2.gamma.meanGamma);
            fprintf('    Œ≥ m√°ximo (LMI): %.6f\n', output_sim2.gamma.maxGamma);
        else
            fprintf('    ‚ö† Campos de gamma n√£o dispon√≠veis\n');
        end

    catch ME
        fprintf('  ‚úó ERRO: %s\n', ME.message);
        resultados_simulacao{2} = [];
    end
    fprintf('\n');

    % SIMULA√á√ÉO 3: H‚àû Robust Polytopic (MONTE CARLO)
    fprintf('--- SIMULA√á√ÉO 3: %s (Monte Carlo) ---\n', nomes_controladores{3});
    try
        imageName = sprintf('Sim3_HInf_Robust_Polytopic');
        flagIsPoly = true;   % Usa an√°lise polit√≥pica
        tic;
        output_sim3 = simulatesSampledInputMonteCarlo(sistemas_monte_carlo_fixos, h, K_robust_polytopic, imageName, axisVector, delta, tol, flagIsPoly);
        tempo_sim3 = toc;

        resultados_simulacao{3} = output_sim3;

        fprintf('  ‚úì Simula√ß√£o conclu√≠da: %.2f s\n', tempo_sim3);

        if isfield(output_sim3, 'maxCost')
            fprintf('    Custo m√°ximo: %.6f\n', output_sim3.maxCost);
            fprintf('    Custo m√©dio: %.6f ¬± %.6f\n', output_sim3.meanCost, output_sim3.stdCost);
        else
            fprintf('    ‚ö† Campos de custo n√£o dispon√≠veis\n');
        end

        if isfield(output_sim3, 'gamma') && isfield(output_sim3.gamma, 'meanGamma')
            fprintf('    Œ≥ m√©dio (LMI): %.6f\n', output_sim3.gamma.meanGamma);
            fprintf('    Œ≥ m√°ximo (LMI): %.6f\n', output_sim3.gamma.maxGamma);
        else
            fprintf('    ‚ö† Campos de gamma n√£o dispon√≠veis\n');
        end

    catch ME
        fprintf('  ‚úó ERRO: %s\n', ME.message);
        resultados_simulacao{3} = [];
    end
    fprintf('\n');

    % SIMULA√á√ÉO 4: H‚àû Continuous with Sampled-Time Implementation (MONTE CARLO)
    fprintf('--- SIMULA√á√ÉO 4: %s (Monte Carlo) ---\n', nomes_controladores{4});
    try
        imageName = sprintf('Sim4_HInf_Continuous_Sampled');
        flagIsPoly = false;  % Usa an√°lise intervalar para implementa√ß√£o amostrada
        tic;
        output_sim4 = simulatesSampledInputMonteCarlo(sistemas_monte_carlo_fixos, h, K_continuous_sampled, imageName, axisVector, delta, tol, flagIsPoly);
        tempo_sim4 = toc;

        resultados_simulacao{4} = output_sim4;

        fprintf('  ‚úì Simula√ß√£o conclu√≠da: %.2f s\n', tempo_sim4);

        if isfield(output_sim4, 'maxCost')
            fprintf('    Custo m√°ximo: %.6f\n', output_sim4.maxCost);
            fprintf('    Custo m√©dio: %.6f ¬± %.6f\n', output_sim4.meanCost, output_sim4.stdCost);
        else
            fprintf('    ‚ö† Campos de custo n√£o dispon√≠veis\n');
        end

        if isfield(output_sim4, 'gamma') && isfield(output_sim4.gamma, 'meanGamma')
            fprintf('    Œ≥ m√©dio (LMI): %.6f\n', output_sim4.gamma.meanGamma);
            fprintf('    Œ≥ m√°ximo (LMI): %.6f\n', output_sim4.gamma.maxGamma);
        else
            fprintf('    ‚ö† Campos de gamma n√£o dispon√≠veis\n');
        end

    catch ME
        fprintf('  ‚úó ERRO: %s\n', ME.message);
        resultados_simulacao{4} = [];
    end
    fprintf('\n');

    %% =================================================================
    %% 5. RESULTADOS ESPEC√çFICOS PARA RESPOSTA AO REVISOR
    %% =================================================================

    fprintf('==================================================================================\n');
    fprintf('                    TABELA DE RESULTADOS PARA O REVISOR\n');
    fprintf('    Monte Carlo analysis with %d random parameter combinations per controller\n', numSimulacoesMC);
    fprintf('==================================================================================\n\n');

    % Cabe√ßalho da tabela principal (expandido para Monte Carlo)
    fprintf('%-25s | %-12s | %-12s | %-12s | %-12s | %-12s | %-12s\n', ...
        'CONTROLADOR/M√âTODO', 'Custo M√°x', 'Custo M√©dio', 'Custo Min', 'Œ≥ M√°x (LMI)', 'Œ≥ M√©dio (LMI)', 'Taxa Sucesso');
    fprintf('%s\n', repmat('-', 110, 1));

    % Dados da tabela - incluindo estat√≠sticas Monte Carlo
    for ctrl = 1:4
        if ~isempty(resultados_simulacao{ctrl})
            sim_result = resultados_simulacao{ctrl};

            % Verificar campos de custo
            if isfield(sim_result, 'maxCost')
                max_cost_str = sprintf('%10.6f', sim_result.maxCost);
                mean_cost_str = sprintf('%10.6f', sim_result.meanCost);
                if isfield(sim_result, 'minCost')
                    min_cost_str = sprintf('%10.6f', sim_result.minCost);
                else
                    min_cost_str = sprintf('%10s', 'N/A');
                end
            else
                max_cost_str = sprintf('%10s', 'N/A');
                mean_cost_str = sprintf('%10s', 'N/A');
                min_cost_str = sprintf('%10s', 'N/A');
            end

            % Verificar campos de gamma
            if isfield(sim_result, 'gamma') && isfield(sim_result.gamma, 'maxGamma')
                max_gamma_str = sprintf('%10.6f', sim_result.gamma.maxGamma);
                mean_gamma_str = sprintf('%10.6f', sim_result.gamma.meanGamma);
            else
                max_gamma_str = sprintf('%10s', 'N/A');
                mean_gamma_str = sprintf('%10s', 'N/A');
            end

            % Taxa de sucesso Monte Carlo
            if isfield(sim_result, 'sim_success_rate')
                success_rate_str = sprintf('%9.1f%%', sim_result.sim_success_rate * 100);
            else
                success_rate_str = sprintf('%10s', 'N/A');
            end

            fprintf('%-25s | %s | %s | %s | %s | %s | %s\n', ...
                nomes_controladores{ctrl}, ...
                max_cost_str, mean_cost_str, min_cost_str, max_gamma_str, mean_gamma_str, success_rate_str);
        else
            fprintf('%-25s | %10s | %10s | %10s | %10s | %10s | %10s\n', ...
                nomes_controladores{ctrl}, 'FALHOU', 'FALHOU', 'FALHOU', 'FALHOU', 'FALHOU', '0.0%');
        end
    end

    fprintf('\n');

    % AN√ÅLISE 1: Compara√ß√£o norm-bounded vs polytopic
    fprintf('==================================================================================\n');
    fprintf('                   AN√ÅLISE 1: NORM-BOUNDED vs POLYTOPIC\n');
    fprintf('    Comparison between norm-bounded and polytopic uncertainty representations\n');
    fprintf('==================================================================================\n\n');

    if ~isempty(resultados_simulacao{2}) && ~isempty(resultados_simulacao{3})
        % Comparar controladores 2 e 3 (Interval vs Polytopic)
        sim_interval = resultados_simulacao{2};    % H‚àû Robust Interval
        sim_polytopic = resultados_simulacao{3};   % H‚àû Robust Polytopic

        fprintf('Compara√ß√£o entre representa√ß√µes de incerteza:\n\n');

        % Verificar quais m√©tricas est√£o dispon√≠veis
        has_cost_interval = isfield(sim_interval, 'maxCost');
        has_cost_polytopic = isfield(sim_polytopic, 'maxCost');
        has_gamma_interval = isfield(sim_interval, 'gamma') && isfield(sim_interval.gamma, 'maxGamma');
        has_gamma_polytopic = isfield(sim_polytopic, 'gamma') && isfield(sim_polytopic.gamma, 'maxGamma');

        if has_gamma_interval && has_gamma_polytopic
            fprintf('%-20s | %-15s | %-15s | %-12s\n', 'M√âTRICA', 'Interval (norm-bounded)', 'Polytopic', 'Melhor');
            fprintf('%s\n', repmat('-', 70, 1));

            % Compara√ß√£o usando apenas Œ≥ (que parece estar dispon√≠vel)
            if has_gamma_interval && has_gamma_polytopic
                % Œ≥ M√°ximo (LMI)
                if sim_interval.gamma.maxGamma < sim_polytopic.gamma.maxGamma
                    vantagem_gamma_max = 'Interval';
                elseif sim_polytopic.gamma.maxGamma < sim_interval.gamma.maxGamma
                    vantagem_gamma_max = 'Polytopic';
                else
                    vantagem_gamma_max = 'Equivalente';
                end
                fprintf('%-20s | %13.6f | %13.6f | %-12s\n', 'Œ≥ M√°ximo (LMI)', sim_interval.gamma.maxGamma, sim_polytopic.gamma.maxGamma, vantagem_gamma_max);

                % Œ≥ M√©dio (LMI)
                if sim_interval.gamma.meanGamma < sim_polytopic.gamma.meanGamma
                    vantagem_gamma_mean = 'Interval';
                elseif sim_polytopic.gamma.meanGamma < sim_interval.gamma.meanGamma
                    vantagem_gamma_mean = 'Polytopic';
                else
                    vantagem_gamma_mean = 'Equivalente';
                end
                fprintf('%-20s | %13.6f | %13.6f | %-12s\n', 'Œ≥ M√©dio (LMI)', sim_interval.gamma.meanGamma, sim_polytopic.gamma.meanGamma, vantagem_gamma_mean);

                % Resumo baseado em Œ≥
                if strcmp(vantagem_gamma_max, 'Interval') || strcmp(vantagem_gamma_mean, 'Interval')
                    fprintf('\nüìä RESULTADO: Abordagem INTERVAL (norm-bounded) tem melhor desempenho\n');
                elseif strcmp(vantagem_gamma_max, 'Polytopic') || strcmp(vantagem_gamma_mean, 'Polytopic')
                    fprintf('\nüìä RESULTADO: Abordagem POLYTOPIC tem melhor desempenho\n');
                else
                    fprintf('\nüìä RESULTADO: Ambas abordagens t√™m desempenho equivalente\n');
                end
            end
        else
            fprintf('‚ö† Dados de Œ≥ n√£o dispon√≠veis - compara√ß√£o limitada\n');
        end

        % Tentar compara√ß√£o com custos se dispon√≠veis
        if has_cost_interval && has_cost_polytopic
            fprintf('\nCompara√ß√£o adicional usando custos de simula√ß√£o:\n');
            fprintf('  Interval - Custo m√°ximo: %.6f, m√©dio: %.6f\n', sim_interval.maxCost, sim_interval.meanCost);
            fprintf('  Polytopic - Custo m√°ximo: %.6f, m√©dio: %.6f\n', sim_polytopic.maxCost, sim_polytopic.meanCost);
        end

    else
        fprintf('‚ö† Uma ou ambas as simula√ß√µes falharam - compara√ß√£o n√£o dispon√≠vel\n');
    end

    % AN√ÅLISE 2: Performance do controlador nominal em cen√°rios incertos
    fprintf('\n==================================================================================\n');
    fprintf('           AN√ÅLISE 2: CONTROLADOR NOMINAL EM CEN√ÅRIOS INCERTOS\n');
    fprintf('    (Significance of uncertainty presence in sampled-time implementation)\n');
    fprintf('==================================================================================\n\n');

    if ~isempty(resultados_simulacao{1})
        sim_nominal = resultados_simulacao{1};  % H‚àû Nominal Sampled

        fprintf('An√°lise da signific√¢ncia das incertezas no sistema amostrado:\n\n');

        fprintf('CONTROLADOR NOMINAL aplicado ao sistema com incertezas polit√≥picas:\n');
        fprintf('  Custo m√°ximo encontrado: %.6f\n', sim_nominal.maxCost);
        fprintf('  Custo m√©dio: %.6f ¬± %.6f\n', sim_nominal.meanCost, sim_nominal.stdCost);
        fprintf('  Œ≥ m√°ximo (LMI): %.6f\n', sim_nominal.gamma.maxGamma);
        fprintf('  Œ≥ m√©dio (LMI): %.6f\n', sim_nominal.gamma.meanGamma);
        fprintf('  Œ≥¬≤ te√≥rico (nominal): %.6f\n', gamma_nominal_sampled^2);

        % Calcular "viola√ß√£o" da garantia te√≥rica
        violacao_gamma = (sim_nominal.gamma.maxGamma^2 - gamma_nominal_sampled^2) / gamma_nominal_sampled^2 * 100;

        fprintf('\nüìä IMPACTO DAS INCERTEZAS:\n');
        if violacao_gamma > 0
            fprintf('  ‚ö† VIOLA√á√ÉO: Œ≥¬≤ real excede te√≥rico em %.1f%%\n', violacao_gamma);
            fprintf('    Isso demonstra que o controlador nominal N√ÉO √â ROBUSTO √†s incertezas!\n');
        else
            fprintf('  ‚úì Œ≥¬≤ real mant√©m-se dentro da garantia te√≥rica\n');
        end

        fprintf('  üìà Varia√ß√£o de desempenho entre v√©rtices: %.1f%% (desvio padr√£o relativo)\n', ...
            (sim_nominal.stdCost / sim_nominal.meanCost) * 100);

    else
        fprintf('‚ö† Simula√ß√£o do controlador nominal falhou - an√°lise n√£o dispon√≠vel\n');
    end

    % AN√ÅLISE 3: Implementa√ß√£o amostrada de controlador cont√≠nuo incerto
    fprintf('\n==================================================================================\n');
    fprintf('        AN√ÅLISE 3: IMPLEMENTA√á√ÉO AMOSTRADA DE CONTROLADOR CONT√çNUO\n');
    fprintf('     (Sampled-time implementation of continuous H‚àû controller)\n');
    fprintf('==================================================================================\n\n');

    if ~isempty(resultados_simulacao{4})
        sim_continuous = resultados_simulacao{4};  % H‚àû Continuous Sampled

        fprintf('Performance da implementa√ß√£o amostrada do controlador cont√≠nuo incerto:\n\n');

        fprintf('CONTROLADOR CONT√çNUO implementado com amostragem:\n');
        fprintf('  Custo m√°ximo: %.6f\n', sim_continuous.maxCost);
        fprintf('  Custo m√©dio: %.6f ¬± %.6f\n', sim_continuous.meanCost, sim_continuous.stdCost);
        fprintf('  Œ≥ m√°ximo (LMI): %.6f\n', sim_continuous.gamma.maxGamma);
        fprintf('  Œ≥ m√©dio (LMI): %.6f\n', sim_continuous.gamma.meanGamma);

        % Compara√ß√£o com m√©todos diretos amostrados
        fprintf('\nCompara√ß√£o com s√≠ntese direta amostrada:\n');
        fprintf('%-20s | %-15s | %-15s | %-15s\n', 'M√âTRICA', 'Cont√≠nuo‚ÜíAmostrado', 'Interval Direto', 'Polytopic Direto');
        fprintf('%s\n', repmat('-', 75, 1));

        if ~isempty(resultados_simulacao{2}) && ~isempty(resultados_simulacao{3})
            fprintf('%-20s | %13.6f | %13.6f | %13.6f\n', 'Custo M√°ximo', ...
                sim_continuous.maxCost, resultados_simulacao{2}.maxCost, resultados_simulacao{3}.maxCost);
            fprintf('%-20s | %13.6f | %13.6f | %13.6f\n', 'Custo M√©dio', ...
                sim_continuous.meanCost, resultados_simulacao{2}.meanCost, resultados_simulacao{3}.meanCost);
            fprintf('%-20s | %13.6f | %13.6f | %13.6f\n', 'Œ≥ M√°ximo (LMI)', ...
                sim_continuous.gamma.maxGamma, resultados_simulacao{2}.gamma.maxGamma, resultados_simulacao{3}.gamma.maxGamma);

            % An√°lise de qual m√©todo √© melhor
            custos_maximos = [sim_continuous.maxCost, resultados_simulacao{2}.maxCost, resultados_simulacao{3}.maxCost];
            [~, melhor_idx] = min(custos_maximos);
            metodos_comp = {'Cont√≠nuo‚ÜíAmostrado', 'Interval Direto', 'Polytopic Direto'};

            fprintf('\nüèÜ MELHOR M√âTODO (custo m√°ximo): %s (%.6f)\n', metodos_comp{melhor_idx}, custos_maximos(melhor_idx));
        end

    else
        fprintf('‚ö† Simula√ß√£o do controlador cont√≠nuo falhou - an√°lise n√£o dispon√≠vel\n');
    end

    % RESUMO FINAL PARA O REVISOR
    fprintf('\n==================================================================================\n');
    fprintf('                         RESUMO EXECUTIVO PARA O REVISOR\n');
    fprintf('    Answers to specific reviewer questions using proper sampled-time analysis\n');
    fprintf('==================================================================================\n\n');

    fprintf('üìã RESPOSTAS DIRETAS √ÄS QUEST√ïES DO REVISOR:\n\n');

    % QUEST√ÉO 1: Compara√ß√£o norm-bounded vs polytopic
    fprintf('1Ô∏è‚É£ COMPARISON between NORM-BOUNDED and POLYTOPIC representations:\n');
    if ~isempty(resultados_simulacao{2}) && ~isempty(resultados_simulacao{3})
        % Verificar se dados est√£o dispon√≠veis
        if isfield(resultados_simulacao{2}, 'maxCost') && isfield(resultados_simulacao{3}, 'maxCost') && ...
           isfinite(resultados_simulacao{2}.maxCost) && isfinite(resultados_simulacao{3}.maxCost)

            custo_interval = resultados_simulacao{2}.maxCost;
            custo_polytopic = resultados_simulacao{3}.maxCost;
            gamma_interval = resultados_simulacao{2}.gamma.maxGamma;
            gamma_polytopic = resultados_simulacao{3}.gamma.maxGamma;
            taxa_sucesso_interval = resultados_simulacao{2}.lmi_success_rate * 100;
            taxa_sucesso_polytopic = resultados_simulacao{3}.lmi_success_rate * 100;

            if custo_interval < custo_polytopic
                fprintf('   ‚úì NORM-BOUNDED (Interval) approach is BETTER\n');
                fprintf('     - Max Œ≥¬≤: %.6f vs %.6f (Polytopic)\n', custo_interval, custo_polytopic);
                fprintf('     - Advantage: %.1f%% lower worst-case bound\n', (custo_polytopic - custo_interval)/custo_polytopic*100);
            elseif custo_polytopic < custo_interval
                fprintf('   ‚úì POLYTOPIC approach is BETTER\n');
                fprintf('     - Max Œ≥¬≤: %.6f vs %.6f (Interval)\n', custo_polytopic, custo_interval);
                fprintf('     - Advantage: %.1f%% lower worst-case bound\n', (custo_interval - custo_polytopic)/custo_interval*100);
            else
                fprintf('   ‚âà Both approaches have EQUIVALENT performance\n');
            end

            fprintf('     - Interval: Œ≥_max=%.4f, Success rate=%.1f%%\n', gamma_interval, taxa_sucesso_interval);
            fprintf('     - Polytopic: Œ≥_max=%.4f, Success rate=%.1f%%\n', gamma_polytopic, taxa_sucesso_polytopic);
        else
            fprintf('   ‚ö† Cannot compare - cost data not available or invalid\n');
        end
    else
        fprintf('   ‚ö† Cannot compare - simulation failures occurred\n');
    end

    % QUEST√ÉO 2: Signific√¢ncia das incertezas
    fprintf('\n2Ô∏è‚É£ SIGNIFICANCE of UNCERTAINTY presence:\n');
    if ~isempty(resultados_simulacao{1})
        sim_nominal = resultados_simulacao{1};
        violacao_percentual = (sim_nominal.gamma.maxGamma^2 - gamma_nominal_sampled^2) / gamma_nominal_sampled^2 * 100;
        variacao_custos = (sim_nominal.stdCost / sim_nominal.meanCost) * 100;

        fprintf('   üìä Nominal controller applied to uncertain system:\n');
        fprintf('     - Performance degradation: %.1f%% above theoretical guarantee\n', max(0, violacao_percentual));
        fprintf('     - Cost variation across uncertainty set: %.1f%%\n', variacao_custos);
        if violacao_percentual > 10
            fprintf('   ‚ö† CRITICAL: Nominal design is NOT ROBUST to uncertainties!\n');
        else
            fprintf('   ‚úì Nominal design shows acceptable robustness\n');
        end
    else
        fprintf('   ‚ö† Cannot assess - nominal simulation failed\n');
    end

    % QUEST√ÉO 3: Implementa√ß√£o amostrada vs cont√≠nua
    fprintf('\n3Ô∏è‚É£ SAMPLED-TIME implementation vs CONTINUOUS design:\n');
    if ~isempty(resultados_simulacao{4}) && ~isempty(resultados_simulacao{2})
        custo_continuous_sampled = resultados_simulacao{4}.maxCost;
        custo_direct_sampled = resultados_simulacao{2}.maxCost;

        fprintf('   üîÑ Continuous controller + Sampled implementation: %.6f\n', custo_continuous_sampled);
        fprintf('   üéØ Direct sampled-time synthesis: %.6f\n', custo_direct_sampled);

        if custo_direct_sampled < custo_continuous_sampled
            fprintf('   ‚úì DIRECT sampled-time synthesis is SUPERIOR\n');
            fprintf('     - Advantage: %.1f%% better performance\n', (custo_continuous_sampled - custo_direct_sampled)/custo_continuous_sampled*100);
        else
            fprintf('   ‚úì Continuous‚ÜíSampled implementation is competitive\n');
            fprintf('     - Advantage: %.1f%% better performance\n', (custo_direct_sampled - custo_continuous_sampled)/custo_direct_sampled*100);
        end
    else
        fprintf('   ‚ö† Cannot compare - simulation failures occurred\n');
    end

    % ESTAT√çSTICAS MONTE CARLO
    fprintf('\nüìä ESTAT√çSTICAS MONTE CARLO DETALHADAS:\n');
    fprintf('   Total de simula√ß√µes por controlador: %d\n', numSimulacoesMC);
    for ctrl = 1:4
        if ~isempty(resultados_simulacao{ctrl}) && isfield(resultados_simulacao{ctrl}, 'numSimulacoes')
            sim_result = resultados_simulacao{ctrl};
            fprintf('   %s:\n', nomes_controladores{ctrl});
            fprintf('     - Simula√ß√µes executadas: %d\n', sim_result.numSimulacoes);
            fprintf('     - Taxa sucesso LMI: %.1f%% (%d/%d)\n', ...
                sim_result.lmi_success_rate*100, round(sim_result.lmi_success_rate*sim_result.numSimulacoes), sim_result.numSimulacoes);
            fprintf('     - Taxa sucesso simula√ß√£o: %.1f%% (%d/%d)\n', ...
                sim_result.sim_success_rate*100, round(sim_result.sim_success_rate*sim_result.numSimulacoes), sim_result.numSimulacoes);

            if isfield(sim_result, 'pior_caso')
                fprintf('     - Pior caso: custo=%.6f (k2=%.3f, b=%.4f)\n', ...
                    sim_result.pior_caso.custo, sim_result.pior_caso.k2, sim_result.pior_caso.b);
            end
            if isfield(sim_result, 'melhor_caso')
                fprintf('     - Melhor caso: custo=%.6f (k2=%.3f, b=%.4f)\n', ...
                    sim_result.melhor_caso.custo, sim_result.melhor_caso.k2, sim_result.melhor_caso.b);
            end
        end
    end

    % EFETIVIDADE DOS M√âTODOS PROPOSTOS
    fprintf('\nüéØ EFFECTIVENESS of PROPOSED METHODS:\n');
    num_sucessos = sum(~cellfun(@isempty, resultados_simulacao));
    fprintf('   - Successful Monte Carlo campaigns: %d/4 controllers\n', num_sucessos);

    if num_sucessos >= 2
        % Encontrar melhor m√©todo robusto
        custos_robustos = [];
        nomes_robustos = {};
        for i = 2:4
            if ~isempty(resultados_simulacao{i})
                custos_robustos(end+1) = resultados_simulacao{i}.maxCost;
                nomes_robustos{end+1} = nomes_controladores{i};
            end
        end

        if ~isempty(custos_robustos)
            [melhor_custo, melhor_idx] = min(custos_robustos);
            fprintf('   üèÜ BEST ROBUST METHOD: %s\n', nomes_robustos{melhor_idx});
            fprintf('     - Best worst-case cost: %.6f\n', melhor_custo);
        end
    end

    % SALVAR RESULTADOS
    fprintf('\n==================================================================================\n');
    fprintf('                              SALVANDO RESULTADOS\n');
    fprintf('==================================================================================\n\n');

    % Estrutura de sa√≠da para o revisor
    saida_revisor.resultados_simulacao = resultados_simulacao;
    saida_revisor.nomes_controladores = nomes_controladores;
    saida_revisor.controladores_gamma = controladores_gamma;
    saida_revisor.controladores_K = controladores_K;
    saida_revisor.sistemas_monte_carlo = sistemas_monte_carlo_fixos;  % Salvar sistemas para an√°lise posterior
    saida_revisor.parametros.h = h;
    saida_revisor.parametros.delta = delta;
    saida_revisor.parametros.tol = tol;
    saida_revisor.parametros.numSimulacoesMC = numSimulacoesMC;
    saida_revisor.parametros.seed_monte_carlo = seed_monte_carlo;
    saida_revisor.sistema.m1 = m1;
    saida_revisor.sistema.m2 = m2;
    saida_revisor.sistema.k1 = k1;
    saida_revisor.sistema.k2 = k2;
    saida_revisor.sistema.b = b;
    saida_revisor.incertezas = 'k2¬±2%, b¬±5%';
    saida_revisor.metodo = 'Monte Carlo com sistemas fixos';
    saida_revisor.timestamp = datestr(now);

    try
        save('resultados_resposta_revisor.mat', 'saida_revisor');
        fprintf('‚úì Resultados salvos em: resultados_resposta_revisor.mat\n');
    catch ME
        fprintf('‚úó Erro ao salvar: %s\n', ME.message);
    end

    fprintf('‚úì Gr√°ficos individuais salvos para cada simula√ß√£o\n');
    fprintf('‚úì An√°lise focada nas quest√µes espec√≠ficas do revisor\n\n');

    fprintf('==================================================================================\n');
    fprintf('                    RESPOSTA AO REVISOR FINALIZADA\n');
    fprintf('                            %s\n', datestr(now));
    fprintf('==================================================================================\n');

end